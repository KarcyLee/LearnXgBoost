> [xgboost C++源码主要函数](xgboost C++源码主要函数)
> [xgboost 源码初探](https://www.jianshu.com/p/8977a2d97234)
>
> [XGBoost解析系列--源码主流程](https://blog.csdn.net/matrix_zzl/article/details/78699605)



[TOC]

> src/cli_main.cc

# 1. 主流程  main函数

```c++
int main(int argc, char *argv[]) {
  return xgboost::CLIRunTask(argc, argv);
}

int CLIRunTask(int argc, char *argv[]) {
	// 省略输入参数校验部分
  // 注：引入了rabit库；rabit是分布式通信库，这里的功能是初始化整个框架的分布特性
  
  // 流程demo在demo/binary_classification/runexp.sh
  switch (param.task) {
    // 训练
    case kTrain: CLITrain(param); break; 
    // dump模型DumpModel
    case kDumpModel: CLIDumpModel(param); break; 
    // 预测Predict
    case kPredict: CLIPredict(param); break;
  }

  // 省略Finalize()部分
  return 0;
}
}

```

# 2. 训练过程CLITrain

```c++
void CLITrain(const CLIParam& param) {
  const double tstart_data_load = dmlc::GetTime();
  // 0. 判断是否分布式
  if (rabit::IsDistributed()) {
    std::string pname = rabit::GetProcessorName();
    LOG(CONSOLE) << "start " << pname << ":" << rabit::GetRank();
  }
  
  // 1. 加载数据，数据会转换成DMatrix类. 定义在data.h
  std::shared_ptr<DMatrix> dtrain(
      DMatrix::Load(
          param.train_path,
          ConsoleLogger::GlobalVerbosity() > ConsoleLogger::DefaultVerbosity(),
          param.dsplit == 2));
  
  std::vector<std::shared_ptr<DMatrix> > deval;
  std::vector<std::shared_ptr<DMatrix> > cache_mats;
  std::vector<DMatrix*> eval_datasets;
  cache_mats.push_back(dtrain);
  for (size_t i = 0; i < param.eval_data_names.size(); ++i) {
    deval.emplace_back(
        std::shared_ptr<DMatrix>(DMatrix::Load(
            param.eval_data_paths[i],
            ConsoleLogger::GlobalVerbosity() > ConsoleLogger::DefaultVerbosity(),
            param.dsplit == 2)));
    eval_datasets.push_back(deval.back().get());
    cache_mats.push_back(deval.back());
  }
  std::vector<std::string> eval_data_names = param.eval_data_names;
  if (param.eval_train) {
    eval_datasets.push_back(dtrain.get());
    eval_data_names.emplace_back("train");
  }
  
  // 2. initialize the learner.
  std::unique_ptr<Learner> learner(Learner::Create(cache_mats));
  int version = rabit::LoadCheckPoint(learner.get());
  if (version == 0) {
    // initialize the model if needed.
    if (param.model_in != "NULL") {
      std::unique_ptr<dmlc::Stream> fi(
          dmlc::Stream::Create(param.model_in.c_str(), "r"));
      learner->Load(fi.get());
      learner->SetParams(param.cfg);
    } else {
      learner->SetParams(param.cfg);
    }
  }
  LOG(INFO) << "Loading data: " << dmlc::GetTime() - tstart_data_load << " sec";

  // start training.
  const double start = dmlc::GetTime();
  for (int i = version / 2; i < param.num_round; ++i) {
    double elapsed = dmlc::GetTime() - start;
    if (version % 2 == 0) {
      LOG(INFO) << "boosting round " << i << ", " << elapsed << " sec elapsed";
      learner->UpdateOneIter(i, dtrain.get());
      if (learner->AllowLazyCheckPoint()) {
        rabit::LazyCheckPoint(learner.get());
      } else {
        rabit::CheckPoint(learner.get());
      }
      version += 1;
    }
    CHECK_EQ(version, rabit::VersionNumber());
    std::string res = learner->EvalOneIter(i, eval_datasets, eval_data_names);
    if (rabit::IsDistributed()) {
      if (rabit::GetRank() == 0) {
        LOG(TRACKER) << res;
      }
    } else {
      LOG(CONSOLE) << res;
    }
    if (param.save_period != 0 &&
        (i + 1) % param.save_period == 0 &&
        rabit::GetRank() == 0) {
      std::ostringstream os;
      os << param.model_dir << '/'
         << std::setfill('0') << std::setw(4)
         << i + 1 << ".model";
      std::unique_ptr<dmlc::Stream> fo(
          dmlc::Stream::Create(os.str().c_str(), "w"));
      learner->Save(fo.get());
    }

    if (learner->AllowLazyCheckPoint()) {
      rabit::LazyCheckPoint(learner.get());
    } else {
      rabit::CheckPoint(learner.get());
    }
    version += 1;
    CHECK_EQ(version, rabit::VersionNumber());
  }
  LOG(INFO) << "Complete Training loop time: " << dmlc::GetTime() - start << " sec";
  // always save final round
  if ((param.save_period == 0 || param.num_round % param.save_period != 0) &&
      param.model_out != "NONE" &&
      rabit::GetRank() == 0) {
    std::ostringstream os;
    if (param.model_out == "NULL") {
      os << param.model_dir << '/'
         << std::setfill('0') << std::setw(4)
         << param.num_round << ".model";
    } else {
      os << param.model_out;
    }
    std::unique_ptr<dmlc::Stream> fo(
        dmlc::Stream::Create(os.str().c_str(), "w"));
    learner->Save(fo.get());
  }

  double elapsed = dmlc::GetTime() - start;
  LOG(INFO) << "update end, " << elapsed << " sec in all";
}
```



